# 面试刷题

## 面试准备概述

通过 Vibe Coding 学习编程后，你可能需要参加技术面试。本章提供面试准备的指导和算法题练习建议。

## 面试流程与类型

### 面试流程

技术面试通常包括：简历筛选、电话面试、技术笔试、现场面试（包括编程测试、系统设计、行为面试等）。

### 面试类型

**编程面试**：现场编写代码，考察编程能力和算法思维。

**系统设计面试**：设计一个系统，考察架构设计能力。

**项目面试**：讨论过往项目，考察实际经验。

**行为面试**：了解你的软技能和团队协作能力。

## 编程面试基础

### 必知概念

**时间复杂度**：算法执行时间随输入规模增长的增长率。

**空间复杂度**：算法使用内存空间随输入规模增长的增长率。

**大 O 表示法**：表示复杂度的标准方式，如 O(1)、O(n)、O(n²)、O(log n)。

### 常见数据结构

**数组**：连续内存，支持随机访问。

**链表**：通过指针连接，插入删除高效。

**栈**：后进先出（LIFO）。

**队列**：先进先出（FIFO）。

**哈希表**：键值对存储，平均 O(1) 查找。

**树**：层次结构，二叉树最常见。

**图**：节点和边的复杂结构。

### 常见算法

**排序**：冒泡、选择、插入、快速、归并、堆排序。

**搜索**：线性搜索、二分搜索。

**递归与回溯**：经典的算法范式。

**动态规划**：解决最优化问题。

**贪心算法**：每步最优，期望全局最优。

## 数组与字符串

### 两数之和

**题目**：给定一个数组和一个目标值，返回两个数的索引，使它们的和等于目标值。

**解法**：使用哈希表存储已遍历过的数字和索引。在遍历过程中，检查 target - nums[i] 是否在哈希表中。

```javascript
function twoSum(nums, target) {
  const map = new Map();
  for (let i = 0; i < nums.length; i++) {
    const complement = target - nums[i];
    if (map.has(complement)) {
      return [map.get(complement), i];
    }
    map.set(nums[i], i);
  }
  return [];
}
```

### 有效的括号

**题目**：判断字符串中的括号是否有效配对。

**解法**：使用栈保存左括号。遇到右括号时检查栈顶是否匹配。

```javascript
function isValid(s) {
  const stack = [];
  const map = { ')': '(', '}': '{', ']': '[' };
  
  for (const char of s) {
    if (char in map) {
      if (stack.pop() !== map[char]) return false;
    } else {
      stack.push(char);
    }
  }
  return stack.length === 0;
}
```

### 旋转数组

**题目**：将数组向右旋转 k 步。

**解法**：使用三次反转。先反转整个数组，再分别反转前后两部分。

```javascript
function rotate(nums, k) {
  k = k % nums.length;
  reverse(nums, 0, nums.length - 1);
  reverse(nums, 0, k - 1);
  reverse(nums, k, nums.length - 1);
}

function reverse(arr, start, end) {
  while (start < end) {
    [arr[start], arr[end]] = [arr[end], arr[start]];
    start++;
    end--;
  }
}
```

## 链表

### 反转链表

**题目**：反转单向链表。

**解法**：迭代法，用三个指针处理。也可以用递归。

```javascript
function reverseList(head) {
  let prev = null;
  let current = head;
  while (current) {
    const next = current.next;
    current.next = prev;
    prev = current;
    current = next;
  }
  return prev;
}
```

### 环形链表

**题目**：判断链表中是否有环。

**解法**：快慢指针法。如果有环，快指针终会追上慢指针。

```javascript
function hasCycle(head) {
  let slow = head;
  let fast = head;
  while (fast && fast.next) {
    slow = slow.next;
    fast = fast.next.next;
    if (slow === fast) return true;
  }
  return false;
}
```

## 栈与队列

### 有效的括号

（见数组与字符串章节）

### 用栈实现队列

**题目**：用两个栈实现队列的 push、pop、peek 操作。

**解法**：一个栈用于输入，一个栈用于输出。pop 时如果输出栈为空，将输入栈的元素全部倒入输出栈。

```javascript
class MyQueue {
  constructor() {
    this.inStack = [];
    this.outStack = [];
  }
  
  push(x) {
    this.inStack.push(x);
  }
  
  pop() {
    if (this.outStack.length === 0) {
      while (this.inStack.length) {
        this.outStack.push(this.inStack.pop());
      }
    }
    return this.outStack.pop();
  }
  
  peek() {
    if (this.outStack.length === 0) {
      while (this.inStack.length) {
        this.outStack.push(this.inStack.pop());
      }
    }
    return this.outStack[this.outStack.length - 1];
  }
  
  empty() {
    return this.inStack.length === 0 && this.outStack.length === 0;
  }
}
```

## 二叉树

### 二叉树遍历

```javascript
// 前序遍历
function preorder(root) {
  if (!root) return;
  console.log(root.val);
  preorder(root.left);
  preorder(root.right);
}

// 中序遍历
function inorder(root) {
  if (!root) return;
  inorder(root.left);
  console.log(root.val);
  inorder(root.right);
}

// 后序遍历
function postorder(root) {
  if (!root) return;
  postorder(root.left);
  postorder(root.right);
  console.log(root.val);
}
```

### 二叉树最大深度

**题目**：计算二叉树的最大深度。

```javascript
function maxDepth(root) {
  if (!root) return 0;
  return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));
}
```

### 验证二叉搜索树

**题目**：判断二叉树是否为有效的二叉搜索树。

```javascript
function isValidBST(root) {
  function validate(node, min, max) {
    if (!node) return true;
    if (min !== null && node.val <= min) return false;
    if (max !== null && node.val >= max) return false;
    return validate(node.left, min, node.val) && 
           validate(node.right, node.val, max);
  }
  return validate(root, null, null);
}
```

## 动态规划

### 斐波那契数列

**题目**：计算第 n 个斐波那契数。

```javascript
// 记忆化递归
function fib(n, memo = {}) {
  if (n in memo) return memo[n];
  if (n <= 1) return n;
  memo[n] = fib(n - 1, memo) + fib(n - 2, memo);
  return memo[n];
}

// 动态规划
function fib(n) {
  if (n <= 1) return n;
  const dp = [0, 1];
  for (let i = 2; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2];
  }
  return dp[n];
}
```

### 爬楼梯

**题目**：爬 n 阶楼梯，每次可以走 1 或 2 步，有多少种走法。

```javascript
function climbStairs(n) {
  if (n <= 2) return n;
  let prev = 1, curr = 2;
  for (let i = 3; i <= n; i++) {
    [prev, curr] = [curr, prev + curr];
  }
  return curr;
}
```

### 最长递增子序列

**题目**：找到数组中最长递增子序列的长度。

```javascript
function lengthOfLIS(nums) {
  if (!nums.length) return 0;
  const tails = [];
  for (const num of nums) {
    let i = 0, j = tails.length;
    while (i < j) {
      const mid = Math.floor((i + j) / 2);
      if (tails[mid] < num) i = mid + 1;
      else j = mid;
    }
    tails[i] = num;
  }
  return tails.length;
}
```

## 面试技巧

### 沟通技巧

**说明思路**：在写代码前，先说明你的思路。这展示了你的思考过程，也让面试官有机会引导你。

**边写边说**：写代码时说出你在做什么。这叫"有声思考"。

**询问澄清**：不确定需求时，勇敢询问。这展示了你的严谨。

### 代码质量

**代码整洁**：使用有意义的变量名。保持一致的代码风格。

**错误处理**：考虑边界情况和错误处理。

**测试用例**：写完代码后，说明你会如何测试。

### 时间管理

**先解决后优化**：先写出正确的解法，再考虑优化。

**预估复杂度**：在写代码前，估算时间空间复杂度。

**及时调整**：如果卡住了，及时调整策略。

## 刷题资源

### 在线平台

**LeetCode**：最流行的算法题库，按公司分类。

**力扣中国**：LeetCode 中文版。

**牛客网**：国内面试题库和面经。

**HackerRank**：多种编程练习。

### 推荐题库

**Top 100 LCP**：面试高频题。

**LeetCode Hot 100**：热门题目。

**剑指 Offer**：经典面试题。

### 学习方法

**分类练习**：按数据结构或算法类型集中练习。

**定期复习**：建立错题本，定期回顾。

**模拟面试**：找朋友模拟面试环境。
