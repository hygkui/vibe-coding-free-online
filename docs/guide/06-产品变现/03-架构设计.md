# 架构设计

## 架构设计概述

好的架构设计可以让系统更容易维护、扩展和优化。本章介绍产品开发中的架构设计原则和实践。

## 架构设计原则

### 单一职责原则

每个模块只做一件事。模块职责单一，变化影响范围小。

### 开闭原则

软件实体应该对扩展开放，对修改关闭。通过扩展而不是修改来增加功能。

### 依赖倒置原则

高层模块不依赖低层模块的具体实现，都依赖抽象。面向接口编程，降低耦合。

### 迪米特法则

一个模块不应该了解太多其他模块的内部细节。只与直接朋友通信。

### KISS 原则

Keep It Simple, Stupid。保持简单，避免过度设计。

## 系统架构模式

### 分层架构

最常见的架构模式：

**表现层**：处理用户界面和交互。

**业务逻辑层**：处理业务规则和逻辑。

**数据访问层**：处理数据存储和访问。

**数据库层**：数据的最终存储。

### 微服务架构

将系统拆分为多个独立的服务，每个服务负责特定功能。服务之间通过 API 通信。适合大型复杂系统。

### Serverless 架构

无服务器架构，将代码部署为函数，按调用付费。适合事件驱动的场景。

### 事件驱动架构

通过事件进行组件间的通信。发布-订阅模式。适合异步处理场景。

## 前端架构设计

### 组件设计

**原子设计**：将组件分为原子、分子、有机体、模板、页面五个层次。

**高内聚低耦合**：每个组件职责单一，组件间通过 props 通信。

**可复用性**：设计可复用的组件，避免重复代码。

### 状态管理

**本地状态**：组件内部的状态，使用 useState 或 ref。

**共享状态**：多个组件需要共享的状态，使用 Pinia/Redux。

**服务端状态**：来自服务器的数据，使用 React Query 或 SWR。

### 目录结构

```
src/
├── components/    # 可复用组件
│   ├── atoms/     # 原子组件（按钮、输入框）
│   ├── molecules/ # 分子组件（表单组）
│   └── organisms/ # 有机体组件（导航栏）
├── views/         # 页面
├── stores/        # 状态管理
├── services/      # API 服务
├── utils/         # 工具函数
├── hooks/         # 自定义 Hooks
└── styles/        # 样式文件
```

## 后端架构设计

### API 设计

**RESTful API**：使用 HTTP 方法表达操作，资源作为路径。标准、易于理解。

**GraphQL**：客户端指定需要的数据，减少数据传输。适合复杂的数据需求。

**gRPC**：高性能的 RPC 框架，使用 Protocol Buffers。适合服务间通信。

### 分层设计

**控制器层**：处理 HTTP 请求和响应。

**服务层**：处理业务逻辑。

**数据访问层**：操作数据库。

**模型层**：定义数据模型。

### 目录结构

```
src/
├── controllers/   # 控制器
├── services/      # 业务逻辑
├── models/        # 数据模型
├── repositories/  # 数据访问
├── middlewares/   # 中间件
├── routes/        # 路由定义
├── utils/         # 工具函数
├── config/        # 配置
└── app.ts         # 应用入口
```

## 数据库设计

### 范式与反范式

**范式化**：减少数据冗余，保持数据一致性。查询可能需要 JOIN。

**反范式化**：增加冗余数据，提高查询性能。增加数据维护成本。

根据实际需求选择合适的范式级别。

### 索引设计

**主键索引**：自动创建，唯一且高效。

**普通索引**：加速查询，但有维护成本。

**复合索引**：多字段组合索引，遵循最左前缀原则。

### 读写分离

对于读多写少的应用，实现读写分离。主库处理写操作，从库处理读操作。

## 架构图绘制

### C4 模型

C4 模型是绘制架构图的常用方法：

**系统上下文图**：展示系统与外部系统的关系。

**容器图**：展示系统的主要构建块（前端、后端、数据库等）。

**组件图**：展示容器的内部组件。

**类图**：展示关键类的设计。

### 绘图工具

**draw.io**：免费在线绘图工具。

**Excalidraw**：手绘风格，简单直观。

**Mermaid**：代码生成图表，版本控制友好。

## 架构演进

### 演进策略

**渐进式演进**：逐步改造，而非一次性重写。

**特性开关**：通过开关控制新旧功能的切换。

**AB 测试**：验证新架构的效果。

### 扩展策略

**水平扩展**：增加服务器数量。

**垂直扩展**：升级服务器配置。

**分库分表**：拆分数据库压力。

## 架构文档

### 架构决策记录（ADR）

记录关键的技术决策：

```
# ADR-001: 选择 Vue 3 作为前端框架

## 状态
已通过

## 背景
需要选择前端框架开发新的 SaaS 产品。

## 决策
选择 Vue 3 作为前端框架。

## 考量因素
- 团队有 Vue 2 经验，学习成本低
- Vue 3 Composition API 提供了更好的代码组织方式
- 生态完善，组件库丰富

## 后果
- 开发速度快，代码质量高
- 需要时间熟悉新特性和最佳实践
```

### 架构文档结构

```
# 架构文档

## 1. 概述
产品介绍、架构概述。

## 2. 系统上下文
与外部系统的关系。

## 3. 技术栈
使用的技术及版本。

## 4. 架构图
系统架构图、组件图。

## 5. 数据设计
数据库设计、数据流。

## 6. API 设计
API 规范、接口文档。

## 7. 部署架构
部署方案、基础设施。

## 8. 安全设计
认证、授权、安全措施。

## 9. 性能考虑
性能目标、优化策略。
```
